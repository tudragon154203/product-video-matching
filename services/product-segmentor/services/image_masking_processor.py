import numpy as np
import cv2
from typing import Optional
from common_py.logging_config import configure_logging

logger = configure_logging("product-segmentor:image_masking_processor")


class ImageMaskingProcessor:
    """
    Handles the core logic for image masking, including foreground and people segmentation
    and combining masks.
    """

    def __init__(self, foreground_segmentor, people_segmentor, file_manager, image_processor):
        self.foreground_segmentor = foreground_segmentor
        self.people_segmentor = people_segmentor
        self.file_manager = file_manager
        self.image_processor = image_processor  # This is the ForegroundProcessor from service.py

    async def process_single_image(self, image_id: str, local_path: str, image_type: str, job_id: str = "unknown") -> Optional[str]:
        """Process a single image to generate mask.

        Args:
            image_id: Unique identifier for the image
            local_path: Path to the source image
            image_type: Type of image ("product" or "frame")
            job_id: Optional job identifier for logging context

        Returns:
            Path to generated mask or None if processing failed
        """
        try:
            foreground_mask = await self._generate_and_load_foreground_mask(image_id, local_path, image_type, job_id)
            if foreground_mask is None:
                return None

            people_mask = await self._generate_and_save_people_mask(image_id, local_path, image_type, job_id)

            final_mask = await self._subtract_people_mask(foreground_mask, people_mask, image_id, job_id)

            mask_path = await self._save_final_product_mask(image_id, final_mask, image_type, job_id)

            return mask_path

        except Exception as e:
            logger.error("Item processing failed",
                         job_id=job_id,
                         asset_id=image_id,
                         asset_type="image",
                         error=str(e),
                         error_type=type(e).__name__)
            return None

    async def _generate_and_load_foreground_mask(
        self, image_id: str, local_path: str, image_type: str, job_id: str
    ) -> Optional[np.ndarray]:
        foreground_mask_path = await self.image_processor.process_image(
            image_id=image_id,
            local_path=local_path,
            image_type=image_type,
            file_manager=self.file_manager,
        )

        if foreground_mask_path is None:
            logger.warning("Item processing failed",
                           job_id=job_id,
                           asset_id=image_id,
                           asset_type="image",
                           error="Failed to generate foreground mask")
            return None

        foreground_mask = cv2.imread(foreground_mask_path, cv2.IMREAD_GRAYSCALE)
        if foreground_mask is None:
            logger.error("Resource not found",
                         job_id=job_id,
                         asset_id=image_id,
                         asset_type="image",
                         resource_type="foreground_mask",
                         mask_path=foreground_mask_path)
            return None

        if foreground_mask.ndim == 3 and foreground_mask.shape[2] == 1:
            foreground_mask = foreground_mask.squeeze(axis=2)

        logger.info("Loading foreground mask from: {foreground_mask_path}", mask_path=foreground_mask_path)
        return foreground_mask

    async def _generate_and_save_people_mask(self, image_id: str, local_path: str, image_type: str, job_id: str) -> Optional[np.ndarray]:
        try:
            logger.debug("Attempting to segment people mask", local_path=local_path)
            people_mask = await self.people_segmentor.segment_image(local_path)
            if people_mask is not None:
                logger.debug("People mask segmented successfully", people_mask_shape=people_mask.shape)
                try:
                    await self.file_manager.save_people_mask(image_id, people_mask, image_type)
                    logger.debug("People mask saved successfully", image_id=image_id, image_type=image_type)
                except Exception as save_e:
                    logger.error("Error saving people mask", error=str(save_e), error_type=type(save_e).__name__, image_id=image_id)
                    return None
            else:
                logger.debug("No people mask generated by segmentor")
            return people_mask
        except Exception as people_e:
            logger.error("Error during people mask segmentation", error=str(people_e),
                         error_type=type(people_e).__name__, local_path=local_path)
            return None

    async def _subtract_people_mask(
        self, foreground_mask: np.ndarray, people_mask: Optional[np.ndarray],
        image_id: str, job_id: str
    ) -> np.ndarray:
        final_mask = foreground_mask
        if people_mask is not None:
            logger.info("Foreground mask shape: {foreground_mask_shape}", foreground_mask_shape=foreground_mask.shape)
            logger.info("People mask shape: {people_mask_shape}", people_mask_shape=people_mask.shape)

            # Ensure both masks have the same dimensionality
            # Foreground mask is already squeezed to 2D in _generate_and_load_foreground_mask
            # People mask might be 3D with shape (H, W, 1), so we need to squeeze it too
            if people_mask.ndim == 3 and people_mask.shape[2] == 1:
                people_mask = people_mask.squeeze(axis=2)
                logger.debug("Squeezed people mask to 2D", new_shape=people_mask.shape)

            if foreground_mask.shape == people_mask.shape:
                try:
                    final_mask = cv2.bitwise_and(foreground_mask, cv2.bitwise_not(people_mask))
                    logger.info("Subtracted people mask from foreground mask", image_id=image_id)
                except Exception as bitwise_e:
                    logger.error(
                        "Error during bitwise operation for mask subtraction",
                        error=str(bitwise_e),
                        error_type=type(bitwise_e).__name__,
                        image_id=image_id,
                        foreground_shape=foreground_mask.shape,
                        people_shape=people_mask.shape,
                    )
                    return foreground_mask  # Fallback to original foreground mask
            else:
                logger.warning("Mask processing warning",
                               job_id=job_id,
                               asset_id=image_id,
                               asset_type="image",
                               error="Foreground and people mask shapes do not match",
                               foreground_shape=foreground_mask.shape,
                               people_shape=people_mask.shape)
        else:
            logger.info("Processing completed with warning",
                        job_id=job_id,
                        asset_id=image_id,
                        asset_type="image",
                        warning="No people mask generated")
        return final_mask

    async def _save_final_product_mask(self, image_id: str, final_mask: np.ndarray, image_type: str, job_id: str) -> Optional[str]:
        try:
            mask_path = await self.file_manager.save_product_final_mask(image_id, final_mask, image_type)
            logger.debug("Final product mask saved", mask_path=mask_path)
            return mask_path
        except Exception as final_save_e:
            logger.error("Error saving final product mask", error=str(final_save_e),
                         error_type=type(final_save_e).__name__, image_id=image_id)
            return None
